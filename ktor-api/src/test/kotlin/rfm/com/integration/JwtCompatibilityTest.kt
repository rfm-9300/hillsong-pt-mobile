package rfm.com.integration

import io.jsonwebtoken.Jwts
import io.jsonwebtoken.security.Keys
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.beans.factory.annotation.Value
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.test.context.TestPropertySource
import rfm.com.security.jwt.JwtTokenProvider
import java.nio.charset.StandardCharsets
import java.util.*
import org.junit.jupiter.api.Assertions.*

/**
 * Test to ensure JWT token compatibility between Ktor and Spring Boot versions.
 * This validates that tokens generated by Spring Boot can be validated and contain
 * the same claims structure as the original Ktor implementation.
 */
@SpringBootTest
@TestPropertySource(properties = [
    "app.jwt.secret=myTestSecretKeyThatIsLongEnoughForHS256Algorithm",
    "app.jwt.expiration=86400000",
    "app.jwt.issuer=http://localhost:8080",
    "app.jwt.audience=users"
])
class JwtCompatibilityTest {

    @Autowired
    private lateinit var jwtTokenProvider: JwtTokenProvider

    @Value("\${app.jwt.secret}")
    private lateinit var jwtSecret: String

    @Value("\${app.jwt.issuer}")
    private lateinit var jwtIssuer: String

    @Value("\${app.jwt.audience}")
    private lateinit var jwtAudience: String

    @Test
    fun `should generate JWT token with correct structure and claims`() {
        // Given
        val userId = 123L
        val email = "test@example.com"

        // When
        val token = jwtTokenProvider.generateTokenFromUserId(userId, email)

        // Then
        assertNotNull(token)
        assertTrue(token.isNotEmpty())
        
        // Verify token structure (should have 3 parts separated by dots)
        val tokenParts = token.split(".")
        assertEquals(3, tokenParts.size, "JWT token should have 3 parts (header.payload.signature)")
    }

    @Test
    fun `should validate JWT token successfully`() {
        // Given
        val userId = 123L
        val email = "test@example.com"
        val token = jwtTokenProvider.generateTokenFromUserId(userId, email)

        // When
        val isValid = jwtTokenProvider.validateToken(token)

        // Then
        assertTrue(isValid, "Generated token should be valid")
    }

    @Test
    fun `should extract correct user ID from JWT token`() {
        // Given
        val userId = 123L
        val email = "test@example.com"
        val token = jwtTokenProvider.generateTokenFromUserId(userId, email)

        // When
        val extractedUserId = jwtTokenProvider.getUserIdFromToken(token)

        // Then
        assertEquals(userId, extractedUserId, "Extracted user ID should match original")
    }

    @Test
    fun `should extract correct email from JWT token`() {
        // Given
        val userId = 123L
        val email = "test@example.com"
        val token = jwtTokenProvider.generateTokenFromUserId(userId, email)

        // When
        val extractedEmail = jwtTokenProvider.getEmailFromToken(token)

        // Then
        assertEquals(email, extractedEmail, "Extracted email should match original")
    }

    @Test
    fun `should include required claims in JWT token`() {
        // Given
        val userId = 123L
        val email = "test@example.com"
        val token = jwtTokenProvider.generateTokenFromUserId(userId, email)

        // When - Parse token manually to verify claims
        val claims = jwtTokenProvider.getClaimsFromToken(token)

        // Then - Verify all required claims are present
        assertEquals(userId.toString(), claims.subject, "Subject should be user ID")
        assertEquals(email, claims["email"], "Email claim should be present")
        assertEquals(jwtIssuer, claims.issuer, "Issuer should match configuration")
        assertNotNull(claims.issuedAt, "Issued at claim should be present")
        assertNotNull(claims.expiration, "Expiration claim should be present")
        
        // Verify expiration is in the future
        assertTrue(
            claims.expiration.after(Date()),
            "Token expiration should be in the future"
        )
    }

    @Test
    fun `should reject expired JWT token`() {
        // Given - Create a token with past expiration
        val userId = 123L
        val email = "test@example.com"
        val now = Date()
        val pastExpiration = Date(now.time - 1000) // 1 second ago
        
        val key = Keys.hmacShaKeyFor(jwtSecret.toByteArray(StandardCharsets.UTF_8))
        val expiredToken = Jwts.builder()
            .subject(userId.toString())
            .claim("email", email)
            .issuer(jwtIssuer)
            .audience().add(jwtAudience).and()
            .issuedAt(Date(now.time - 2000))
            .expiration(pastExpiration)
            .signWith(key)
            .compact()

        // When
        val isValid = jwtTokenProvider.validateToken(expiredToken)

        // Then
        assertTrue(!isValid, "Expired token should be invalid")
    }

    @Test
    fun `should reject JWT token with invalid signature`() {
        // Given
        val userId = 123L
        val email = "test@example.com"
        val validToken = jwtTokenProvider.generateTokenFromUserId(userId, email)
        
        // Tamper with the token by changing the last character
        val tamperedToken = validToken.dropLast(1) + "X"

        // When
        val isValid = jwtTokenProvider.validateToken(tamperedToken)

        // Then
        assertTrue(!isValid, "Tampered token should be invalid")
    }

    @Test
    fun `should handle malformed JWT token gracefully`() {
        // Given
        val malformedToken = "not.a.valid.jwt.token"

        // When
        val isValid = jwtTokenProvider.validateToken(malformedToken)

        // Then
        assertTrue(!isValid, "Malformed token should be invalid")
    }

    @Test
    fun `should generate different tokens for different users`() {
        // Given
        val user1Id = 123L
        val user1Email = "user1@example.com"
        val user2Id = 456L
        val user2Email = "user2@example.com"

        // When
        val token1 = jwtTokenProvider.generateTokenFromUserId(user1Id, user1Email)
        val token2 = jwtTokenProvider.generateTokenFromUserId(user2Id, user2Email)

        // Then
        assertTrue(token1 != token2, "Different users should have different tokens")
        
        // Verify each token contains correct user information
        assertEquals(user1Id, jwtTokenProvider.getUserIdFromToken(token1))
        assertEquals(user1Email, jwtTokenProvider.getEmailFromToken(token1))
        assertEquals(user2Id, jwtTokenProvider.getUserIdFromToken(token2))
        assertEquals(user2Email, jwtTokenProvider.getEmailFromToken(token2))
    }
}